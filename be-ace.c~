/*
*
*/

#ifdef BE_ACE

#include "backends.h"
#include "be-ace.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hash.h"
#include "log.h"
#include "envs.h"
#include <curl/curl.h>


struct recvData{
	char *data; 
	size_t size;
};

static struct recvData token_introspection_result;

size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata){
	size_t real_size = size * nmemb;
	struct recvData *recv_data = (struct recvData *)userdata;

	recv_data->data = realloc(recv_data->data, recv_data->size + real_size + 1); 
	if(recv_data->data == NULL){
		_log(LOG_DEBUG, "Not enough memory\n");
		return 0;  
	} 

	memcpy(&(recv_data->data[recv_data->size]), ptr, real_size); 
	recv_data->size += real_size;
	recv_data->data[recv_data->size]=0;
	return real_size;
}

static int get_string_envs(CURL *curl, const char *required_env, char *querystring){
	
	char *data = NULL;
	char *escaped_key = NULL;
	char *escaped_val = NULL;
	char *env_string = NULL;

	char *params_key[MAXPARAMSNUM];
	char *env_names[MAXPARAMSNUM];
	char *env_value[MAXPARAMSNUM];

	int i, num = 0; 

	env_string =  (char *)malloc(strlen(required_env)+20); 
	if (env_string == NULL){
		_fatal("ENOMEM");
		return(-1);
	}
	sprintf(env_string, "%s", required_env); 
	
	num = get_sys_envs(env_string, ",", "=", params_key, env_names, env_value); 
	
	for(i=0; i < num; i++){
		escaped_key = curl_easy_escape(curl, params_key[i],0); 
		escaped_val = curl_easy_escape(curl, env_value[i], 0); 
		
		_log(LOG_DEBUG, "key=%s", params_key[i]); 
		_log(LOG_DEBUG, "escaped_key=%s", escaped_key); 
		_log(LOG_DEBUG, "escaped_val=%s", escaped_val); 
		
		data = (char *)malloc(strlen(escaped_key) + strlen(escaped_val) + 1); 
		
		if (data == NULL){
			_fatal("ENOMEM"); 
			return(-1); 
		}
		sprintf(data,"%s=%s&",escaped_key, escaped_val); 
		if (i==0) {
			sprintf(querystring, "%s", data); 
		} else {
			strcat(querystring, data); 
		}
	}
	
	if(data) free(data); 
	if(escaped_key) free(escaped_key); 
	if(escaped_val) free(escaped_val); 
	free(env_string); 
	return(num); 	
}


//modify this code so password field parsed into token and mac
//also we have to parse the data returned; so need to check getinfo of curl
static int http_post(void *handle, char *uri, const char *clientid, const char *username, const char *token,  const char *topic, int acc, int method)
{	
	
	struct ace_backend *conf = (struct ace_backend *)handle; 
	CURL *curl; 
	struct curl_slist *headerlist=NULL;
	
	int re;
	int respCode = 0; 
	int ok = FALSE; 
	char *url;
	char *data; 

	token_introspection_result.data = malloc(1); 
	token_introspection_result.size = 0;

	if (token == NULL){
		return (FALSE); 
	} 
	
	if ((curl = curl_easy_init()) == NULL) {
		_fatal("create curl_easy_handle fails"); 
		return (FALSE); 
	} 

	if (conf->hostheader != NULL)
		headerlist = curl_slist_append(headerlist, conf->hostheader); 
	headerlist = curl_slist_append(headerlist, "Expect:"); 
	

	if (conf->basic_auth != NULL) 
		headerlist = curl_slist_append(headerlist, conf->basic_auth); 

	url = (char *)malloc(strlen(conf->ip) + strlen(uri) + 20); 
	if (url == NULL){
		_fatal("ENOMEM"); 
		return (FALSE); 
	}

	//enable the https
	if (strcmp(conf->with_tls, "true") == 0){
		sprintf(url, "https://%s:%d%s", conf->ip, conf->port, uri);
	} else {
		sprintf(url, "http://%s:%d%s", conf->ip, conf->port, uri); 
	
	}

	char *escaped_token = curl_easy_escape(curl, token, 0);   

        //what is this?
	char string_acc[20];
	snprintf(string_acc, 20, "%d", acc); 

	char *string_envs = (char *)malloc(MAXPARAMSLEN); 
	if (string_envs == NULL){
		_fatal("ENOMEM"); 
		return (FALSE); 
	}
	
	memset(string_envs, 0, MAXPARAMSLEN); 
	
	//get the sys envs
	int env_num = 0; 
	if (method == METHOD_GETUSER && conf->getuser_envs != NULL){
		env_num = get_string_envs(curl, conf->getuser_envs, string_envs); 
	} else if (method == METHOD_SUPERUSER && conf->superuser_envs != NULL) {
		env_num = get_string_envs(curl, conf->superuser_envs, string_envs); 
	} else if (method == METHOD_ACLCHECK && conf->aclcheck_envs != NULL) {
		env_num = get_string_envs(curl, conf->aclcheck_envs, string_envs); 
	}
	if(env_num == -1){
		return (FALSE); 
	}
	
	data = (char *)malloc(strlen(string_envs) + strlen(escaped_token) + 10); 

	if (data == NULL){
		_fatal("ENOMEM"); 
		return (FALSE);
	}

	sprintf(data, "%stoken=%s", 
		string_envs, 
		escaped_token); 

	_log(LOG_DEBUG, "url=%s", url); 
	_log(LOG_DEBUG, "data=%s", data); 
	
	curl_easy_setopt(curl, CURLOPT_URL, url); 
	curl_easy_setopt(curl, CURLOPT_POST, 1L); 
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data); 
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist); 
	curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);   
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10); 
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback); 	
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&token_introspection_result); 

	re = curl_easy_perform(curl); 
	if (re == CURLE_OK){

		re = curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &respCode); 
		if (re == CURLE_OK & respCode >= 200 && respCode < 300){
			ok=TRUE;
		} else if (re == CURLE_OK && respCode >= 500){
			ok = BACKEND_ERROR; //Where is it defined?
		} else {
			//fill in for authentication?
		}
	} else {
		_log(LOG_DEBUG, "http req fail url=%s re=%s", url, curl_easy_strerror(re)); 
		ok = BACKEND_ERROR; 
	}

	curl_easy_cleanup(curl); 
	curl_slist_free_all(headerlist); 
	free(url); 
	free(data);
	free(string_envs); 
	free(escaped_token);  
	return (ok); 
}

void *be_ace_init(){
	struct ace_backend *conf; 
	char *ip; 
	char *getuser_uri;
	char *superuser_uri;
	char *aclcheck_uri;

	if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
		_fatal("init curl fail"); 
		return (NULL); 
	}

	if ((ip = p_stab("http_ip")) == NULL) {
		_fatal("Mandatory parameter `http_ip' missing"); 
		return (NULL); 
	}

	if ((getuser_uri = p_stab("http_getuser_uri")) == NULL) {
		_fatal("Mandatory parameter `http_getuser_uri' missing"); 
		return (NULL); 
	}

	if ((superuser_uri =p_stab("http_superuser_uri")) == NULL) {
		_fatal("Mandatory parameter `http_superuser_uri' missing"); 
		return (NULL); 
	}

	if ((aclcheck_uri = p_stab("http_aclcheck_uri")) == NULL) {
		_fatal("Mandatory parameter `http_aclcheck_uri' missing");
		return (NULL); 
	}

	conf = (struct ace_backend *)malloc(sizeof(struct ace_backend)); 
	conf->ip = ip; 
	conf->port = p_stab("http_port") == NULL ? 80 : atoi(p_stab("http_port")); 
	if (p_stab("http_hostname") != NULL) {
		conf->hostheader = (char *)malloc(128); 
		sprintf(conf->hostheader, "Host: %s", p_stab("http_hostname")); 
	} else {
		conf->hostheader = NULL; 
	}


	conf->getuser_uri = getuser_uri;
	conf->superuser_uri = superuser_uri;
	conf->aclcheck_uri = aclcheck_uri;

	conf->getuser_envs = p_stab("http_getuser_params"); 
	conf->superuser_envs = p_stab("http_superuser_params"); 
	conf->aclcheck_envs = p_stab("http_aclcheck_params"); 
	if(p_stab("http_basic_auth_key") != NULL){
		conf->basic_auth = (char *)malloc(strlen("Authorization: Basic %s") + strlen(p_stab("http_basic_auth_key"))); 
		sprintf(conf->basic_auth, "Authorization: Basic %s", p_stab("http_basic_auth_key")); 
	}	

	if(p_stab("http_wit_tls") != NULL){
		conf->with_tls = p_stab("http_with_tls"); 
	} else {
		conf->with_tls = "false";
	}

	 conf->retry_count = p_stab("http_retry_count") == NULL ? 3 : atoi(p_stab("http_retry_count")); 

	_log(LOG_DEBUG, "with_tls=%s", conf->with_tls);
	_log(LOG_DEBUG, "getuser_uri=%s", getuser_uri); 
	_log(LOG_DEBUG, "superuser_uri=%s", superuser_uri); 
	_log(LOG_DEBUG, "aclcheck_uri=%s", aclcheck_uri); 
	_log(LOG_DEBUG, "getuser_params=%s", conf->getuser_envs); 
	_log(LOG_DEBUG, "superuser_params=%s", conf->superuser_envs); 
	_log(LOG_DEBUG, "aclcheck_params=%s", conf->aclcheck_envs); 
	_log(LOG_DEBUG, "retry_count=%d", conf->retry_count); 

	return (conf); 
};

void be_ace_destroy(void *handle){
	struct ace_backend *conf = (struct ace_backend *)handle;
	
	if (conf){
		curl_global_cleanup(); 
		free(conf); 
	}
};


//decide how you want to implement username, and password
//shall we implement retries or not?
char *be_ace_getuser(void *handle, const char *username, const char *token_mac, int *authenticated) 
{
	struct ace_backend *conf = (struct ace_backend *)handle;
	int re, try; 

	char *mac, *token, *token_to_introspect;

	char *as_result;
	char *secret_key=NULL, *secret_key_beg, *secret_key_end;

	if (token_mac  == NULL){
		return NULL;
	}


	_log(LOG_DEBUG,"username=%s",username);
	_log(LOG_DEBUG,"token=%s", token_mac);


	if(strcmp(username,"ace")==0){
		token=strstr(token_mac, "token:"); 
		mac = strstr(token_mac, "mac:"); 

		if(!token || !mac){
			_log(LOG_DEBUG, "Error: No token or mac"); 
			return NULL;
		} else {
			token+=strlen("token:");
			token_to_introspect = (char *) malloc(mac-token+1); 
			memcpy(token_to_introspect, token, mac-token); 
			token_to_introspect[mac-token]='\0';

			mac += strlen("mac:");
			_log(LOG_DEBUG, "Token to introspect=%s", token_to_introspect); 
			_log(LOG_DEBUG, "MAC=%s", mac); 
		}
		
	} else {
		_log(LOG_DEBUG, "Error: user not ace");
		return NULL;
	}


	re = BACKEND_ERROR; 
	try = 0; 

	while (re == BACKEND_ERROR && try <= conf->retry_count){
		try++;
		re = http_post(handle, conf->getuser_uri, NULL, NULL, token_to_introspect, NULL, -1, METHOD_GETUSER); 
	}
	
	if (re == 1){
		//checking the response
		 _log(LOG_DEBUG, "ACE Result: %s", token_introspection_result.data);
                 as_result = strstr(token_introspection_result.data,"\"active\":true");
		//get the key
		if(as_result){
	 		secret_key_beg = strstr(token_introspection_result.data, "\"k\":\"");
			secret_key_beg += strlen("\"k\":\"");
			secret_key_end = strstr(token_introspection_result.data, "\"}}}");
			if(secret_key_beg && secret_key_end){
				secret_key = (char *) malloc(secret_key_end-secret_key_beg+1);
				memcpy(secret_key, secret_key_beg, secret_key_end-secret_key_beg);
				secret_key[secret_key_end-secret_key_beg]='\0';
				_log(LOG_DEBUG, "Secret key: %s", secret_key);
		
			//Digest of the token with key (which is the password)- something fishy when we add key?
          digest = EVP_get_digestbyname("sha512");
          if(!digest){
                fprintf(stderr, "Error: Unable to create openssl digest.\n");
                return 1;
          }
#if OPENSSL_VERSION_NUMBER < 0x10100000L
        EVP_MD_CTX_init(&context);
        EVP_DigestInit_ex(&context, digest, NULL);
        EVP_DigestUpdate(&context, final_password, strlen(final_password));
        if(key){
          EVP_DigestUpdate(&context, key, strlen(key));
        }
        EVP_DigestFinal_ex(&context, hash, &hash_len);
        EVP_MD_CTX_cleanup(&context);
#else
        context = EVP_MD_CTX_new();
        EVP_DigestInit_ex(context, digest, NULL);
        EVP_DigestUpdate(context, final_password, strlen(final_password));
        if(key){
          EVP_DigestUpdate(context, key, strlen(key));
        }
        EVP_DigestFinal_ex(context, hash, &hash_len);
        EVP_MD_CTX_free(context);
#endif



			}
		}

                 if(as_result)
                          *authenticated = 1;
                  else
                          *authenticated = 0;
	}


	free(token_to_introspect);	
	free(secret_key);

	return NULL;
	
}

int be_ace_superuser(void *handle, const char *token)
{
	struct ace_backend *conf = (struct ace_backend *)handle;
	int re, try;

	re = BACKEND_ERROR;
	try = 0; 
	
	while (re == BACKEND_ERROR && try <= conf->retry_count) {
		try++;
		re = http_post(handle, conf->superuser_uri, NULL, token, NULL,NULL, -1, METHOD_SUPERUSER);
	}
	return re;
};

int be_ace_aclcheck(void *handle, const char *clientid, const char *token, const char *topic, int acc)
{
	struct ace_backend *conf = (struct ace_backend *)handle;
	int re, try; 
	
	re = BACKEND_ERROR; 
	try = 0; 

	while (re == BACKEND_ERROR && try <= conf->retry_count){
		try++; 
		re = http_post(conf, conf->aclcheck_uri, clientid, token, NULL, topic, acc, METHOD_ACLCHECK); 
	}	
	return re;
}	

#endif //BE_ACE
